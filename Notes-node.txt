313 via node/express

*Todo*
Define round class including deal() - done and go_out() - TODO
Define user class - basic, done
Define hand class including draw() and discard() - done 

Create game
 - pass array of users to constructor - done
 - order of users determines user_order - done
 - insert rows in db - TODO
 
Start round 
 - shuffle(), deal() - done
 - prompt user_one to draw and discard - done

During round
 - users prompted to draw/discard in order
 - update db at end of each user's turn - or save & cache 'til end of round?
   - including round.deck, game_user.user_hand, and round.user_order_next

End of round
 - if(turn), user can go_out() (includes discard action)
   -- validate user's hand - if invalid, round continues
   -- if valid, update user's score & clear user's hand
   -- set end_of_round = true: all other users get only one more turn
      -- after each discard(), evaluate each of their hands and calculate score
 - after last user has discarded, start next round 


Rewire for private method testing:
//import rewire from 'rewire';
//const round = rewire('../../src/models/round');
    // https://www.npmjs.com/package/rewire
//    const setNextUp = round.__get__('setNextUp');


*Resources*
https://github.com/ryym/mocha-each
https://box.scotch.io/
https://wsvincent.com/javascript-object-oriented-deck-cards/
https://www.killerphp.com/tutorials/php-objects-page-1/
https://www.brainbell.com/tutorials/php/php7-oop-beginners.html
https://www.valuebound.com/resources/blog/understanding-phpunit-and-how-to-write-unit-test-cases
https://www.php.net/serialize
https://codinginfinite.com/getting-started-web-application-php-mysql-tutorials/
https://www.taniarascia.com/create-a-simple-database-app-connecting-to-mysql-with-php/
https://catswhocode.com/phpcache/
https://www.web-development-blog.com/why-should-you-cache-your-php-website/

------------------------------------------------------------------
CardGroup
add(card)
remove(card)
move(card, target: CardGroup) {
  remove(card)
  target.add(card)
}
getCards()
toString()

Deck extends CardGroup
shuffle()
dealOneCard()
assemble()

Hand extends CardGroup
evaluateHand()
findFilteredCards()
findWildCards()
removeValidRunsFromHand()
removeCardArrayFromHand()

Leftovers extends CardGroup


------------------------------------------------------------------
Logic for checking gin rummy hand from https://github.com/jlyden/straight-gin/blob/master/utils.py#L60

def test_hand(hand):
    """
    Calculate deadwood penalty of Straight_Gin hand
    hand: list of strings
    Return integer penalty of unplayable ("deadwood") cards in hand
    Resources consulted:
    http://stackoverflow.com/questions/7352684/how-to-find-the-groups-of-consecutive-elements-from-an-array-in-numpy
    https://docs.python.org/2/library/itertools.html#itertools.groupby
    http://stackoverflow.com/questions/1450111/delete-many-elements-of-list-python
    http://stackoverflow.com/questions/7025581/how-can-i-group-equivalent-items-together-in-a-python-list
    """
    suits = clean_hand(hand)

    # set up variables
    long_runs = []
    leftovers = []

    # look for runs within each suit
    for suit in suits:
        suit.sort()
        # if at least 3 cards in suit, test for a run
        if len(suit) > 2:
            groups = group_consecutives(suit)
            for group in groups:
                # if group is run of at least 3 different numbers
                if len(group) > 2 and group[0] != group[-1]:
                    # store long_runs to help with sets later
                    if len(group) > 3:
                        long_runs.append(group)
                    # remove cards used in run from suit
                    suit[:] = [item for i, item in enumerate(suit)
                               if item not in group]
            # after removing from suit all cards in run-groups,
            # dump remaining cards in suit to leftovers
            leftovers += suit
        # if too few cards in suit for a run, add cards in suit to leftovers
        else:
            leftovers += suit

    # check leftovers for sets of duplicate numbers
    leftovers, long_runs = check_sets(leftovers, long_runs)
    # (twice in case of buried last cards)
    leftovers, long_runs = check_sets(leftovers, long_runs)

    # calculate penalty (face card pts != 10)
    penalty = sum(leftovers)
    return penalty
--------------------------------
check sets ...

def check_sets(leftovers, long_runs):
    """
    Sort & group leftovers by number
    Remove sets of 3 or 4 cards of same value from leftovers
    Look in long_runs (where run > 3) for completion cards for 1 or 2 card sets
    Return transformed leftovers & long_runs
    """
    # group leftovers by number
    leftovers.sort()
    sets = [list(g) for k, g in groupby(leftovers)]
    for set in sets:
        # if set of 3 or 4, just remove cards from leftovers
        if len(set) == 3 or len(set) == 4:
            leftovers[:] = [item for i, item in enumerate(leftovers)
                            if item not in set]
        # if set of 2 or 1, look for help in long_runs
        elif len(set) == 2 or len(set) == 1:
            for run in long_runs:
                # if number in set is first or last value in a long_run,
                # we can finish the set with that card!
                # 1) remove set cards from leftovers
                # 2) remove run from long_run
                # 3) if run > 4 (long enough to remove one card and still
                #    BE a long_run), put new_run (without the used set card)
                #    back in long_run
                if set[0] == run[0]:
                    leftovers[:] = [item for i, item in enumerate(leftovers)
                                    if item not in set]
                    long_runs.remove(run)
                    if len(run) > 4:
                        new_run = run[1:]
                        long_runs.append(new_run)
                elif set[0] == run[-1]:
                    leftovers[:] = [item for i, item in enumerate(leftovers)
                                    if item not in set]
                    long_runs.remove(run)
                    if len(run) > 4:
                        new_run = run[:-1]
                        long_runs.append(new_run)
    return leftovers, long_runs
